## hook

可以在函数组件中使用状态，生命周期。 有状态的函数组件

## 为什么使用 hook

class 的替代方案

- class 组件复用不方便
  hook 可以不改变组件结构的方式复用逻辑
- 组件拆分
  calss 组件会比较复杂，难以拆分。hook 可以把相关联的部分拆分成更小的函数
- 不易理解，性能
  this 指向不明确

hook 可以在函数组件中使用 class 特性, hook+函数组件替代 class

## 使用规则

在**函数组件或自定义组件**，**最外部**调用

自定义组件命名推荐以 use 开头

## 内置 hook 通过 hook 钩如 class 的特性

### state hook 钩入 state 特性

- 使用格式 const [count, setCount] = useState(0);
- 多个 useState()会有自己的数据存储位置
  每个组件内部都有一个列表数据格式，每当调用一次 useState()就会获取对应位置数据，并将指针向后移动一位
- 如果调用 setSate() useState 会返回新的 state, 如果没有调用 setState useState 会返回原先的值

### effect hook 可以使用 class 生命周期的特性

```js
useEffect(() => {
  console.log("effect");
  // 代码一
  return () => {
    console.log("effect return");
    //   代码二
  };
});
```

| useEffect(fn,[]) 参数          | 初次渲染   | 更新渲染                                           | 销毁       |
| ------------------------------ | ---------- | -------------------------------------------------- | ---------- |
| 没有第二个参数                 | 执行代码一 | 执行代码二，代码一                                 | 执行代码二 |
| 有第二个参数（是空数组）       | 执行代码一 | 不执行                                             | 执行代码二 |
| 有第二个参数（是有参数的数组） | 执行代码一 | 当参数改变（执行代码二，代码一），不改变（不执行） | 执行代码二 |

推荐使用

- 多个 effect 可以分离逻辑，实现关注点分离
- 添加第二个参数进行优化，减少不必要的执行，参数要求：
  - 应该是外部作用域中和 effect 中同时使用到的变量，
  - 并且该变量会随时间而发生变化

### useCallbak

优化子组件渲染，如果要给子组件传递一个函数，该函数可以用 useCallback 保证每次使用相同引用的函数，避免子组件无必要的刷新

### useMemo

优化计算，如果函数组件中有计算的话，可以用 useMemo 来优化计算，如果依赖参数无变化可直接返回之前的值。
